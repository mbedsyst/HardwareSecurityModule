#include "../../Keys/Inc/KeyHandler.h"

#include "KeyManager.h"
#include "Generator.h"
#include "Logger.h"

#include "constants.h"
#include "types.h"

#include <stdlib.h>
#include <string.h>

#include "stm32h5xx_hal.h"

// Define the max number of random bytes that can be requested
#define MAX_RANDOM_BYTES 4096
// Externally link RNG Instance
extern RNG_HandleTypeDef hrng;

static uint32_t ConvertKeyIDToUint32(const uint8_t keyID[4])
{
    return ((uint32_t)keyID[0]) |
           ((uint32_t)keyID[1] << 8) |
           ((uint32_t)keyID[2] << 16) |
           ((uint32_t)keyID[3] << 24);
}

static uint16_t CalculateKeySize(uint8_t option_member)
{
	uint16_t byteSize;
	switch(option_member)
	{
		case OPTION_RNG_0016: byteSize = 16; 	break;
		case OPTION_RNG_0024: byteSize = 24; 	break;
		case OPTION_RNG_0032: byteSize = 32; 	break;
		case OPTION_RNG_0048: byteSize = 48; 	break;
		case OPTION_RNG_0064: byteSize = 64; 	break;
		case OPTION_RNG_0066: byteSize = 66; 	break;
		case OPTION_RNG_0128: byteSize = 128; 	break;
		case OPTION_RNG_0256: byteSize = 256; 	break;
		case OPTION_RNG_0384: byteSize = 384; 	break;
		case OPTION_RNG_0512: byteSize = 512; 	break;
		default: break;
	}
	return byteSize;
}

static OperationStatus_t KeyHandler_Generate(const ParsedPacket_t* request, ResponsePacket_t* response)
{
    log_info("Handling Key Generation operation.");
    // Variable to hold word alignment overflow count
    uint16_t remainder = 0;
    // Retrieve requested OPTION byte from Request Packet
    uint8_t option_val = (request->option);
    // Set the requested Pad size
    uint16_t numBytes = CalculateKeySize(option_val);
    // Checking if requested byte count is word aligned
    if(numBytes % 4)
    {
    	log_info("Padding RNG Output to be word aligned.");
    	remainder = numBytes % 4;
    	numBytes += remainder;
    }
    log_info("Generating %d bytes of One-Time Pad", numBytes - remainder);
    // Check if the requested size is within the limits
    if (numBytes == 0 || numBytes > MAX_RANDOM_BYTES)
    {
        log_error("Requested Pad count is invalid.");
        return OPERATION_INVALID_OPTION;
    }
    // Declare a status handler for RNG calls
    HAL_StatusTypeDef hal_status;
    // Declare a 32-bit variable to store generated word
    uint32_t randomValue;
    // Iterate through loop till required number of random words are filled
    for (uint8_t i = 0; i < numBytes/4; ++i)
    {
    	// Call HAL API to generate 32-bit random word
    	hal_status = HAL_RNG_GenerateRandomNumber(&hrng, &randomValue);
    	// Check if API call returned successfully
	    if (hal_status != HAL_OK)
	    {
	    	log_error("Failed to generate random number from RNG peripheral.");
		    return OPERATION_KEY_GEN_FAIL;
	    }
	    // Append generated random word to response packet
        response->outputData[i] = (uint8_t)(randomValue & 0xFF);
    }
    // Set the Output Size to number of randomly generated bytes
    response->outputSize = numBytes - remainder;
    log_info("One-Time Pad Generation Operation complete.");
    return OPERATION_SUCCESS;
}

static OperationStatus_t KeyHandler_Store(const ParsedPacket_t* request, ResponsePacket_t* response)
{
    log_info("Handling Key Store operation.");

    // Check if either Request or Response Packet is NULL
    if (!request )
    {
    	log_error("Request Packet is NULL.");
        return OPERATION_INVALID_INPUT_DATA;
    }

    // Declare variables to hold Key ID, Key Value, and Key Usage information.
    uint8_t keyID[4] = {0};
    uint32_t keyID_32 = 0;
    uint8_t keyVal[32] = {0};

    // Retrieve Key Size, Key Usage and Key Value from Request Packet
    uint8_t keySize = request->inputSize - 1;
    uint8_t keyUsage = request->inputData[0];
    memcpy(keyVal, &request->inputData[1], keySize);

    // Generate 4-byte Key ID
    GenerateKEYID(keyID);
    // Convert 4-byte Key ID array into 32-bit unsigned integer
    keyID_32 = ConvertKeyIDToUint32(keyID);
    // Call Key Manager to Add Key to Storage medium
    if(KeyManager_AddKey(keyID_32, keyVal, keySize, KEY_ORIGIN_PROVIDED, keyUsage) != 0)
    {
    	log_error("Failed to Add Key to Storage Medium.");
    	return OPERATION_KEY_STORE_FAIL;
    }

    // Set the Output Size to the size of Key ID
    response->outputSize = 4;
    memcpy(&response->outputData, keyID, 4);
    log_info("Key Store Operation complete.");
    return OPERATION_SUCCESS;
}

static OperationStatus_t KeyHandler_Delete(const ParsedPacket_t* request, ResponsePacket_t* response)
{
    log_info("Handling Key Delete operation.");

    // Check if either Request or Response Packet is NULL
    if (!request )
    {
    	log_error("Request Packet is NULL.");
        return OPERATION_INVALID_INPUT_DATA;
    }

    // Declare variables to hold Key ID.
    uint8_t keyID[4] = {0};
    uint32_t keyID_32 = 0;

    // Retrieve Key ID from Request Packet
    memcpy(keyID, &request->inputData[0], 4);

    // Convert 4-byte Key ID array into 32-bit unsigned integer
    keyID_32 = ConvertKeyIDToUint32(keyID);
    // Call Key Manager to Add Key to Storage medium
    if(KeyManager_DeleteKey(keyID_32) != 0)
    {
    	log_error("Failed to Delete Key from Storage Medium.");
    	return OPERATION_KEY_DELETE_FAIL;
    }

    // Set the Output Size to 2 for zeroing output data
    response->outputSize = 2;
    memset(&response->outputData, 0, 2);
    log_info("Key Delete Operation complete.");
    return OPERATION_SUCCESS;
}

OperationStatus_t KeyHandler_Handle(const ParsedPacket_t* request, ResponsePacket_t* response)
{
	switch(request->option)
	{
		case OPTION_KEY_GEN:
			log_info("Handling Key Generation operation.");
			return KeyHandler_Generate(request, response);

		case OPTION_KEY_STORE:
			log_info("Handling Key Store operation in KMS.");
			return KeyHandler_Store(request, response);

		case OPTION_KEY_DELETE:
			log_info("Handling Key Store operation in KMS.");
			return KeyHandler_Delete(request, response);

        default:
            log_error("Invalid Option code received");
            log_error("Returning Failure Status code");
            return OPERATION_INVALID_OPTION;
	}
	return 0;
}

