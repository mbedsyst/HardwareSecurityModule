#include "../../Keys/Inc/KeyHandler.h"
#include "Logger.h"
#include "constants.h"
#include "types.h"
#include <stdlib.h>
#include <string.h>

#include "stm32h5xx_hal.h"

// Define the max number of random bytes that can be requested
#define MAX_RANDOM_BYTES 4096
// Externally link RNG Instance
extern RNG_HandleTypeDef hrng;

static uint16_t CalculateKeySize(uint8_t option_member)
{
	uint16_t byteSize;
	switch(option_member)
	{
		case OPTION_RNG_0016: byteSize = 16; 	break;
		case OPTION_RNG_0024: byteSize = 24; 	break;
		case OPTION_RNG_0032: byteSize = 32; 	break;
		case OPTION_RNG_0048: byteSize = 48; 	break;
		case OPTION_RNG_0064: byteSize = 64; 	break;
		case OPTION_RNG_0066: byteSize = 66; 	break;
		case OPTION_RNG_0128: byteSize = 128; 	break;
		case OPTION_RNG_0256: byteSize = 256; 	break;
		case OPTION_RNG_0384: byteSize = 384; 	break;
		case OPTION_RNG_0512: byteSize = 512; 	break;
		default: break;
	}
	return byteSize;
}

static OperationStatus_t KeyHandler_Generate(const ParsedPacket_t* request, ResponsePacket_t* response)
{
    log_info("Handling Key Generation operation.");
    // Retrieve requested OPTION half-word from Request Packet
    uint8_t option_val = (request->option);
    // Set the requested Pad size
    uint16_t numBytes = CalculateKeySize(option_val);
    log_info("Generating %d bytes of One-Time Pad", numBytes);
    // Check if the requested size is within the limits
    if (numBytes == 0 || numBytes > MAX_RANDOM_BYTES)
    {
        log_error("Requested Pad count is too big.");
        return OPERATION_INVALID_OPTION;
    }
    // Declare a status handler for RNG calls
    HAL_StatusTypeDef hal_status;
    // Declare a 32-bit variable to store generated word
    uint32_t randomValue;
    // Iterate through loop till required number of random words are filled
    for (uint8_t i = 0; i < numBytes/4; ++i)
    {
    	// Call HAL API to generate 32-bit random word
    	hal_status = HAL_RNG_GenerateRandomNumber(&hrng, &randomValue);
    	// Check if API call returned successfully
	    if (hal_status != HAL_OK)
	    {
	    	log_error("Failed to generate random number from RNG peripheral.");
		    return OPERATION_RANDOM_GEN_FAIL;
	    }
	    // Append generated random word to response packet
        response->outputData[i] = (uint8_t)(randomValue & 0xFF);
    }
    // Set the Output Size to number of randomly generated bytes
    response->outputSize = numBytes;
    log_info("One-Time Pad Generation Operation complete.");
    return OPERATION_SUCCESS;
}

static OperationStatus_t KeyHandler_Store(const ParsedPacket_t* request, ResponsePacket_t* response)
{
	return OPERATION_UNKNOWN_ERROR;
}

static OperationStatus_t KeyHandler_Erase(const ParsedPacket_t* request, ResponsePacket_t* response)
{
	return OPERATION_UNKNOWN_ERROR;
}

OperationStatus_t KeyHandler_Handle(const ParsedPacket_t* request, ResponsePacket_t* response)
{
	switch(request->cmd)
	{
		case CMD_KEY_GEN:
			log_info("Handling Key Generation operation.");
			return KeyHandler_Generate(request, response);

		case CMD_KEY_STORE:
			log_info("Calling Key Store operation.");
			log_warn("Key Store operation not supported now.");
			return KeyHandler_Store(request, response);

		case CMD_KEY_ERASE:
			log_info("Calling Key Store operation.");
			log_warn("Key Store operation not supported now.");
			return KeyHandler_Erase(request, response);

		default:
			break;
	}

	return 0;
}

